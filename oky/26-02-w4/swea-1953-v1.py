# SWEA-1953 탈옥범 검거

"""
1. 터널 연결 로직
   현재 위치에서 '나갈 수 있는 방향'과 다음 위치의 '진입 허용 조건'을 리스트 기반으로 매칭하여,
   물리적으로 연결된 터널로만 이동하도록 구현함
2. 가지치기
   동일 좌표에 더 적은 시간이 남은 상태로 도착한 경우 탐색을 즉시 종료하여,
   대형 맵에서의 중복 연산 방지
3. 이동 시마다 시간을 차감하며 탐색하고,
   최종적으로 딕셔너리에 기록된 좌표의 개수를 추출하여 도달 가능한 지점의 총합 산출
"""
#==========================================================================


T = int(input())

# 방향 벡터 (상, 하, 좌, 우)
dr = [-1, 1, 0, 0]
dc = [0, 0, -1, 1]

# 각 터널 구조물 타입별로 '이동 가능한' 방향
# 상(0), 하(1), 좌(2), 우(3)
possible_directions = [[],
                       [0, 1, 2, 3],  # 상 하 좌 우
                       [0, 1],        # 상 하
                       [2, 3],        # 좌 우
                       [0, 3],        # 상 우
                       [1, 3],        # 하 우
                       [1, 2],        # 하 좌
                       [0, 2]]        # 상 좌

# 진입 방향에 따른 '연결 가능한' 터널 구조물 타입
# 예시: 상(0) 방향에 있는 터널이 1, 2, 5, 6번 터널이어야 이동 가능
connectable_types = [[1, 2, 5, 6],
                     [1, 2, 4, 7],
                     [1, 3, 4, 5],
                     [1, 3, 6, 7]]

def move(r, c, time):
    # 현재 위치의 터널 타입에서 이동 가능한 방향(i) 순회
    for i in possible_directions[tunnels[r][c]]:
        nr = r + dr[i]
        nc = c + dc[i]

        # 1) 경계 검사 (인덱스 에러 방지)
        if not (0 <= nr < N and 0 <= nc < M):
            continue
        # 2) 이동할 칸의 터널이 현재 칸과 연결될 수 없는 모양이면 무시
        elif not tunnels[nr][nc] in connectable_types[i]:
            continue
        # 3) 이미 방문한 적이 있고, 현재 남은 시간(time-1)이 이전 방문 때보다 적거나 같다면 무시
        # [OPTIMIZE] 가지치기
        # >> 이 조건 없이 N과 M이 50 이상인 테스트케이스를 돌리면 시간 초과됨
        # [OPTIMIZE] elif (nr, nc) in escaper and cnt - 1 <= escaper[(nr, nc)]:
        # >> 값이 있는지 확인하고(in), 있으면 꺼내온다([])는 두 번의 절차를 거침
        # get() 함수 사용하여 개선
        elif time - 1 <= reachable.get((nr, nc), -1):
            # (1) 키가 존재하는 경우: 해당 좌표에 저장된 남은 시간 값 반환
            # (2) 키가 없는 경우(첫 방문): 기본값 -1 반환
            #     >> 'cnt-1 <= -1'은 항상 False가 되어 통과
            continue

        # 이동 가능한 위치로 판단되면 이동 가능 시간 1 감소
        left_time = time - 1
        # 이동 좌표를 결과 딕셔너리에 추가. 이미 방문한 좌표라면 최대 남은 시간 갱신
        reachable[(nr, nc)] = left_time
        # 잔여 시간이 있다면 다음 탐색 진행 (재귀)
        if left_time > 0:
            move(nr, nc, left_time)

for test_case in range(1, T + 1):
    N, M, R, C, L = map(int, input().split())
    tunnels = [list(map(int, input().split())) for _ in range(N)]

    # 시작점(맨홀 뚜껑 위치)을 포함한 결과 변수 생성
    # {좌표: 남은 시간} : 딕셔너리를 사용하여 남은 시간 기록 및 중복 제거
    reachable = {(R, C): L-1}

    # L==1이면 시작점에서 이동할 수 없으므로 함수 호출하지 않고 바로 결과 출력
    if L > 1:
        # 시작점에서 남은 이동 가능 시간을 기록하고 탐색 시작
        move(R, C, L-1)

    print(f'#{test_case} {len(reachable)}')
