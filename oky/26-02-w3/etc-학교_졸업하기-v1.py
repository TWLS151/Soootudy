# A형 15기 기출 1번


# [문제]===================================================================
"""

당신의 학과에는 N개의 필수 과목들이 있다.
과목들은 1번부터 N번까지 번호가 붙어 있다.
한 학기에는 가능한 모든 과목을 한꺼번에 들을 수 있다
각 과목에는 선수 과목의 번호들이 있어서 선수 과목들 중 하나라도 이전 학기까지 완료하지 못한 경우는 해당 과목을 실패한다.
물론 첫 학기에는 이전 학기까지 완료한 과목이 없다.
선수 과목들 모두를 이전 학기까지 완료한 경우는 이번 학기에 해당 과목을 완료하게 된다.
선수 과목이 없는 과목은 첫 학기에 완료된다.
모든 과목을 완료하는 데 몇 학기가 필요한지 계산하라.
아래 그림과 같은 상황을 생각하자.

그림에는 4개의 과목이 있으며 화살표가 나가는 과목이 들어가는 과목의 선수 과목이라는 의미이다
1번째 학기에는 4번 과목만 (선수 과목이 없으므로) 완료가 가능하다.
2번째 학기에는 3번 과목만 완료가 되고, 3번째 학기에는 1번 과목이, 마지막으로 4번째 학기에 2번 과목이 완료된다.
모든 과목을 완료하는 데 몇 학기가 필요한지 계산하라.
모든 과목을 완료하는 것이 불가능할 수도 있음에 주의하라.

[제약사항]
1. 과목의 개수 N은 2 이상 100 이하이다. (2 ≤ N ≤ 100)
2. 과목들의 선수과목 개수의 총 합은 1 이상 120 이하이다.
3. 선수 과목의 개수가 0인 과목이 하나도 없을 수도 있다.

[입력]
가장 첫 줄에는 테스트 케이스의 총 수가 주어진다.
그 다음 줄부터 각 테스트 케이스가 주어지며, 각 테스트 케이스는 N+1줄로 구성된다.
각 테스트 케이스의 첫 번째 줄에는 과목의 수 N이 주어진다.
다음 N개의 줄에 번호 순서대로 각 과목의 선수 과목들의 번호가 주어진다.
X번 과목에 해당하는 한 줄에는 X번 과목의 선수 과목 개수가 주어지고 (개수가 0일 수 있음에 주의하라),
다음에 그 개수 만큼의 과목들 번호가 주어진다.
한 줄에 주어지는 번호에 중복은 없다.

[출력]
출력의 각 줄은 ‘#x’로 시작하고, 공백을 한 칸 둔 다음 모든 과목을 완료하는데 필요한 최소 학기 수를 출력한다.
단, x는 테스트 케이스의 번호이다. 모든 과목을 완료하는 것이 불가능한 경우 -1을 출력한다.

"""


# [코드 작동 원리]============================================================
"""
각 과목의 선수 과목 정보를 바탕으로 이수 학기를 계산하되,
학기 갱신이 일어날 때마다 재귀 탐색을 통해 후속 과목들의 학기를 연쇄 업데이트하며
이수 완료 여부를 판별하는 로직

1. 과목을 1번부터 N번까지 순회하며, 해당 과목의 모든 선수 과목 중
   최대 학기 값에 1을 더해 현재 과목의 이수 학기를 초기화한다.

2. 특정 과목의 학기가 업데이트될 경우, 재귀 함수를 호출하여
   이 과목을 선수 과목으로 삼는 모든 후속 과목의 학기를 밀어낸다.

3. 업데이트 과정에서 필요한 학기 수가 총 과목 수 N을 초과하게 되면,
   과목 간 순환 참조(Cycle)가 발생한 것으로 판단하여 -1을 반환한다.
"""


# [코드]===================================================================

T = int(input())

# 특정 과목의 학기가 갱신되었을 때, 그 과목을 선수 과목으로 하는 후속 과목들의 학기를 연쇄적으로 갱신
def check_sub(subject, sub, sem):
    # subject를 선수 과목으로 가지는 후속 과목 k 확인
    for k in sub[subject]:
        # 후속 과목의 학기가 선수 과목 학기보다 작거나 같다면 갱신 필요
        if sem[k] <= sem[subject]:
            sem[k] = sem[subject] + 1
            # 학기 수가 총 과목 수(N)를 초과하면 무한 루프로 간주하여 함수 종료, -1 반환
            if sem[k] > len(sem) - 1:
                return -1
            # 갱신된 학기를 바탕으로 다시 후속 과목들 탐색 (재귀)
            check_sub(k, sub, sem)
        else:
            continue

for test_case in range(1, T + 1):
    # 총 과목 수
    N = int(input())
    # 선수 과목 데이터 (0번 인덱스: 해당 과목의 선수 과목 개수, 1번 이후: 선수 과목 번호들)
    subjects = [list(map(int, input().split())) for _ in range(N)]

    # 각 과목당 필요한 최소 학기 저장 (1로 초기화)
    # 과목 번호가 1부터 시작하므로 0번 인덱스는 비워둠
    semester = [1] * (N + 1)
    # 각 과목 번호를 인덱스로 하여 '그 과목 이후에 들을 과목들(후속 과목)'을 담는 리스트
    sub_seq = [[] for _ in range(N + 1)]
    subject_num = 0

    # 언패킹을 활용해 선수 과목 개수(n)와 리스트(pre_req)를 분리하여 순회
    for n, *pre_req in subjects:
        # 1번 과목부터 차례대로 번호 매김
        subject_num += 1

        # 선수 과목이 존재하는 경우
        if n != 0:
            # 1) 현재 과목의 학기 결정: 선수 과목 중 가장 늦게 끝나는 학기 + 1
            semester[subject_num] = max(max(semester[x] for x in pre_req) + 1, semester[subject_num])

            # 2) # 각 선수 과목들의 '후속 과목 목록'에 현재 과목 번호를 추가
            for i in pre_req:
                sub_seq[i].append(subject_num)

            # 3) 현재 과목의 학기가 변했으므로, 이 과목을 먼저 수강해야하는 후속 과목들의 학기 갱신 (재귀함수 호출)
            # 무한 루프로 간주되어 -1을 반환한다면 반복 종료, 결과 변수에 -1 할당
            if check_sub(subject_num, sub_seq, semester) == -1:
                result = -1
                break
    else:
        # 모든 루프가 정상 종료되면 가장 큰 학기 값을 결과 변수에 할당
        result = max(semester)

    print(f'#{test_case} {result}')

